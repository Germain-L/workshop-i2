This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-17T07:37:35.613Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  bot.py
  commands.py
  config.py
  database.py
  moderation.py
.gitignore
Dockerfile
main.py
README.md
requirements.txt

================================================================
Repository Files
================================================================

================
File: src/bot.py
================
import discord
from discord.ext import commands
import logging
from .moderation import active_conversations, reset_conversation_timer, start_auto_moderation
from .commands import ModCommands

# Set up logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

async def setup_bot():
    intents = discord.Intents.all()
    intents.messages = True
    intents.guilds = True

    bot = commands.Bot(command_prefix='!', intents=intents)
    bot.remove_command('help')

    # Add this line to load the commands
    await bot.add_cog(ModCommands(bot))

    @bot.event
    async def on_ready():
        logger.info(f'Logged in as {bot.user}!')
        bot.loop.create_task(start_auto_moderation(bot))

    @bot.event
    async def on_message(message):
        if message.author == bot.user:
            return

        conversation_id = message.channel.id

        if conversation_id not in active_conversations:
            active_conversations[conversation_id] = {
                "messages": [],
                "user_messages": [],
                "timer": None,
            }
            logger.info(f"Started new conversation for channel {conversation_id}.")

        active_conversations[conversation_id]["messages"].append(message.content)
        active_conversations[conversation_id]["user_messages"].append({
            "id": message.author.id,
            "name": message.author.name,
            "content": message.content,
            "message_id": message.id  # Store the message ID
        })
        logger.info(f"Added message to conversation {conversation_id}: {message.content}")

        await reset_conversation_timer(conversation_id, bot)
        await bot.process_commands(message)

    return bot

================
File: src/commands.py
================
from discord.ext import commands
from .moderation import moderate_conversation
from .database import get_user_score, get_top_users, get_moderation_stats

class ModCommands(commands.Cog):
    def __init__(self, bot):
        self.bot = bot

    @commands.command()
    async def moderate_now(self, ctx):
        await moderate_conversation(ctx, self.bot)

    @commands.command()
    async def user_score(self, ctx, user: commands.UserConverter):
        score = await get_user_score(user.id)
        await ctx.send(f"{user.name}'s score: {score}")

    @commands.command()
    async def leaderboard(self, ctx):
        top_users = await get_top_users(10)
        leaderboard_message = "üèÜ Top 10 Users:\n\n"
        for i, (username, score) in enumerate(top_users, 1):
            leaderboard_message += f"{i}. {username}: {score} points\n"
        await ctx.send(leaderboard_message)

    @commands.command()
    async def modstats(self, ctx):
        total_moderated, channels_moderated = await get_moderation_stats()
        stats_message = f"üìä Moderation Statistics:\n\n"
        stats_message += f"Total messages moderated: {total_moderated}\n"
        stats_message += f"Channels moderated: {channels_moderated}\n"
        await ctx.send(stats_message)

    @commands.command()
    async def help(self, ctx):
        help_message = (
            "Here are the commands you can use:\n"
            "`!moderate_now`: Manually moderate the ongoing conversation in this channel.\n"
            "`!user_score @user`: Check the score of a specific user.\n"
            "`!leaderboard`: Display the top 10 users with the highest scores.\n"
            "`!modstats`: Display moderation statistics.\n"
            "The score will be adjusted based on message harmfulness.\n"
            "\n"
            "For additional assistance, please reach out to a moderator."
        )
        await ctx.send(help_message)

================
File: src/config.py
================
import os
from dotenv import load_dotenv

load_dotenv()

DISCORD_TOKEN = os.environ["DISCORD_TOKEN"]
MISTRAL_API_KEY = os.environ["MISTRAL_API_KEY"]
DATABASE_URL = os.environ["DATABASE_URL"]
model = os.environ.get("MODEL", "mistral-large-latest")
SCORE_ALERT_THRESHOLD = os.environ.get("SCORE_ALERT_THRESHOLD", -5)
AUTO_MODERATE_INTERVAL = 600

active_conversations = {}
last_alert_time = {}
ALERT_COOLDOWN = 3600

================
File: src/database.py
================
import asyncpg
from .config import DATABASE_URL, SCORE_ALERT_THRESHOLD
db = None

async def create_pool():
    global db
    db = await asyncpg.create_pool(DATABASE_URL)

async def create_database():
    async with db.acquire() as conn:
        await conn.execute('''CREATE TABLE IF NOT EXISTS users
                              (id BIGINT PRIMARY KEY, username TEXT, score INTEGER)''')
        await conn.execute('''CREATE TABLE IF NOT EXISTS moderated_messages
                              (message_id BIGINT PRIMARY KEY, channel_id BIGINT)''')

async def get_user_score(user_id):
    async with db.acquire() as conn:
        return await conn.fetchval("SELECT score FROM users WHERE id = $1", user_id) or 0


async def update_user_score(user_id, username, score_change):
    async with db.acquire() as conn:
        await conn.execute("""
            INSERT INTO users (id, username, score) 
            VALUES ($1, $2, $3)
            ON CONFLICT (id) DO UPDATE 
            SET username = EXCLUDED.username, score = users.score + $3
            RETURNING score
        """, user_id, username, score_change)

        new_score = await conn.fetchval("SELECT score FROM users WHERE id = $1", user_id)

        if new_score <= SCORE_ALERT_THRESHOLD:
            return True
        return False

async def is_message_moderated(message_id, channel_id):
    async with db.acquire() as conn:
        return await conn.fetchrow("SELECT * FROM moderated_messages WHERE message_id = $1 AND channel_id = $2", message_id, channel_id) is not None

async def mark_message_as_moderated(message_id, channel_id):
    async with db.acquire() as conn:
        await conn.execute("""
            INSERT INTO moderated_messages (message_id, channel_id)
            VALUES ($1, $2)
            ON CONFLICT (message_id) DO NOTHING
        """, message_id, channel_id)

async def get_top_users(limit=10):
    async with db.acquire() as conn:
        return await conn.fetch("SELECT username, score FROM users ORDER BY score DESC LIMIT $1", limit)

async def get_moderation_stats():
    async with db.acquire() as conn:
        total_moderated = await conn.fetchval("SELECT COUNT(*) FROM moderated_messages")
        channels_moderated = await conn.fetchval("SELECT COUNT(DISTINCT channel_id) FROM moderated_messages")
    return total_moderated, channels_moderated

================
File: src/moderation.py
================
import asyncio
import json
import logging
import time

from mistralai import Mistral
from .config import MISTRAL_API_KEY, model, last_alert_time, ALERT_COOLDOWN, AUTO_MODERATE_INTERVAL
from .database import update_user_score, mark_message_as_moderated, is_message_moderated

logger = logging.getLogger(__name__)

mistral_client = Mistral(api_key=MISTRAL_API_KEY)

active_conversations = {}

async def reset_conversation_timer(conversation_id, bot):
    if active_conversations[conversation_id]["timer"]:
        active_conversations[conversation_id]["timer"].cancel()

    active_conversations[conversation_id]["timer"] = asyncio.create_task(close_conversation(conversation_id, bot))

async def close_conversation(conversation_id, bot):
    await asyncio.sleep(180)
    await moderate_conversation(bot.get_channel(conversation_id), bot)


async def reset_conversation_timer(conversation_id, bot):
    if active_conversations[conversation_id]["timer"]:
        active_conversations[conversation_id]["timer"].cancel()

    active_conversations[conversation_id]["timer"] = asyncio.create_task(close_conversation(conversation_id, bot))

async def close_conversation(conversation_id, bot):
    await asyncio.sleep(180)
    await moderate_conversation(bot.get_channel(conversation_id), bot)

async def start_auto_moderation(bot):
    while True:
        await asyncio.sleep(AUTO_MODERATE_INTERVAL)
        for channel_id in active_conversations:
            channel = bot.get_channel(channel_id)
            if channel:
                await moderate_conversation(channel, bot)

async def moderate_conversation(ctx, bot):
    conversation_id = ctx.channel.id

    if conversation_id in active_conversations:
        messages = active_conversations[conversation_id]["messages"]
        user_messages = active_conversations[conversation_id]["user_messages"]

        # Filter out command messages
        user_messages = [msg for msg in user_messages if not msg['content'].startswith('!')]

        logger.info(f"Moderation requested for conversation {conversation_id}: {messages}")

        if not user_messages:
            logger.info(f"No new messages to moderate in conversation {conversation_id}.")
            return

        moderation_response = await moderate_messages(user_messages)

        if moderation_response:
            harmfulness_level = moderation_response.get("harmfulness_level", "none")
            reasons = moderation_response.get("reasons", [])
            action_required = moderation_response.get("action_required", "")
            user_scores = moderation_response.get("user_scores", {})

            for message in user_messages:
                author_id = message['id']
                author_name = message['name']
                message_id = message['message_id']
                score_change = user_scores.get(author_name, 0)

                if not await is_message_moderated(message_id, conversation_id):
                    alert_needed = await update_user_score(author_id, author_name, score_change)
                    await mark_message_as_moderated(message_id, conversation_id)

                    if alert_needed:
                        await send_moderator_alert(ctx, author_id, author_name)

            log_moderation(conversation_id, reasons, action_required, user_scores)

            logger.info(f"Moderation completed for {len(user_messages)} new messages in conversation {conversation_id}. Harmfulness level: {harmfulness_level}. Reasons: {', '.join(reasons)}")

            active_conversations[conversation_id]["messages"] = []
            active_conversations[conversation_id]["user_messages"] = []
        else:
            logger.info(f"No harmful content detected in the new messages for conversation {conversation_id}.")
    else:
        logger.info(f"No active conversation found for moderation in channel {conversation_id}.")

async def moderate_messages(user_messages):
    conversation_text = "\n".join([f"{msg['name']}: {msg['content']}" for msg in user_messages])
    messages = [
        {
            "role": "user",
            "content": f"Moderate the following conversation:\n{conversation_text}\nEach message is preceded by the user's name. Respond with a JSON object that includes 'harmfulness_level', 'reasons', 'action_required', and 'user_scores'. The 'user_scores' should be an object where keys are usernames and values are integers representing the score change for that user (-2 for highly harmful, -1 for moderately harmful, 0 for neutral, 1 for positive contributions)."
        }
    ]

    try:
        chat_response = mistral_client.chat.complete(
            model=model,
            messages=messages,
            response_format={
                "type": "json_object",
            }
        )

        if chat_response.choices:
            response_json = json.loads(chat_response.choices[0].message.content)
            return response_json
        else:
            return {"harmfulness_level": "none", "reasons": [], "action_required": "", "user_scores": {}}
    except Exception as e:
        logger.error(f"An error occurred while calling Mistral: {e}")
        return {"harmfulness_level": "none", "reasons": [], "action_required": "", "user_scores": {}}

def log_moderation(conversation_id, reasons, action_required, user_scores):
    with open("moderation_log.txt", "a") as log_file:
        log_file.write(f"{conversation_id} - Action Required: {action_required} - Reasons: {', '.join(reasons)} - User Scores: {json.dumps(user_scores)}\n")
    logger.info(f"Moderation logged for conversation {conversation_id}. Reasons: {', '.join(reasons)}, User Scores: {user_scores}")

async def send_moderator_alert(ctx, user_id, username):
    current_time = time.time()
    if user_id in last_alert_time and current_time - last_alert_time[user_id] < ALERT_COOLDOWN:
        logger.info(f"Skipping alert for user {username} (ID: {user_id}) due to cooldown")
        return

    moderator_channel = ctx.guild.get_channel(1296367023948955728)
    if moderator_channel:
        await moderator_channel.send(f"‚ö†Ô∏è ALERT: User {username} (ID: {user_id}) has reached a concerning score level. Please review their recent activity.")
        last_alert_time[user_id] = current_time
        logger.info(f"Sent alert for user {username} (ID: {user_id})")

================
File: .gitignore
================
.env
venv/
moderation.db
moderation_log.txt

================
File: Dockerfile
================
# Use an official Python runtime as a base image
FROM python:3.11-slim

# Set the working directory in the container
WORKDIR /app

# Copy the current directory contents into the container at /app
COPY . /app

# Install any needed packages specified in requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

# Make port 8000 available to the world outside this container
EXPOSE 8000

# Define environment variable
ENV PYTHONUNBUFFERED=1

# Run the application
CMD ["python", "main.py"]

================
File: main.py
================
import asyncio
from src.bot import setup_bot
from src.database import create_pool, create_database
from src.config import DISCORD_TOKEN

async def main():
    bot = await setup_bot()
    await create_pool()
    await create_database()
    await bot.start(DISCORD_TOKEN)

if __name__ == "__main__":
    asyncio.run(main())

================
File: README.md
================
# workshop-i2

================
File: requirements.txt
================
aiohappyeyeballs==2.4.3
aiohttp==3.10.10
aiosignal==1.3.1
annotated-types==0.7.0
anyio==4.6.2
asyncpg==0.29.0
attrs==24.2.0
certifi==2024.8.30
discord.py==2.4.0
eval_type_backport==0.2.0
frozenlist==1.4.1
h11==0.14.0
httpcore==1.0.6
httpx==0.27.2
idna==3.10
jsonpath-python==1.0.6
mistralai==1.1.0
multidict==6.1.0
mypy-extensions==1.0.0
propcache==0.2.0
psycopg2-binary==2.9.9
pydantic==2.9.2
pydantic_core==2.23.4
python-dateutil==2.8.2
python-dotenv==1.0.1
six==1.16.0
sniffio==1.3.1
typing-inspect==0.9.0
typing_extensions==4.12.2
yarl==1.15.2
